#version 450
#extension GL_GOOGLE_include_directive : enable
#include "SharedData.glsl"

layout(std430, binding = 0) buffer AccelOut {
	vec3 accel[ ];
};

layout(std430, binding = 1) buffer ContactIdIn {
	int id0[ ];
};

layout(std430, binding = 2) buffer ContactPairIdIn {
	int val0[ ];
};

layout(std430, binding = 3) buffer LambdaIn {
	float lambda[ ];
};

layout(std430, binding = 4) buffer BIn {
	vec3 B[ ];
};

layout (binding = 5) uniform UBO {
	ContactInfo cntInfo;
};

layout (local_size_x = 64) in;

void main() 
{
    uvec3 id = gl_GlobalInvocationID; 

	uint index = id.x;
	if (index >= cntInfo.constraintNum) 
		return;

    if (index == 0 || id0[index] != id0[index-1])
    {
        int start_index = int(index);
        int bodyId = id0[index];

        while(id0[start_index] == bodyId && start_index < cntInfo.constraintNum)
        {
            int pairId = val0[start_index];

            float lambda_i = lambda[pairId];

            float frac = pairId < cntInfo.contactNum ? SPLIT_MASS : 0.5 * SPLIT_MASS;

            vec3 B1 = frac*lambda_i*B[4*pairId];
            vec3 B2 = frac*lambda_i*B[4*pairId + 1];
            // vec3 B3 = lambda_i*B[4*index + 2];
            // vec3 B4 = lambda_i*B[4*index + 3];

            accel[2*bodyId] += B1;
            accel[2*bodyId + 1] += B2;

            // if (id1 != INVALID_ID) {
            //     accel[2*id1] += B3;
            //     accel[2*id1 + 1] += B4;
            // }
            start_index++;
        }
    }
}