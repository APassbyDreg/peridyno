#version 450
#extension GL_GOOGLE_include_directive : enable
#include "SharedData.glsl"
#include "../math/Quat.glsl"

layout(std430, binding = 0) buffer LambdaPositionOut {
	vec3 lambdaDeltaPosition[ ];
};

layout(std430, binding = 1) buffer LambdaAngularOut {
	vec3 lambdaDeltaAngular[ ];
};

layout(std430, binding = 2) buffer MassInvIn {
	float massInv[ ];
};

layout(std430, binding = 3) buffer InertiaWorldIn {
	mat3 inertiaWorldInv[ ];
};

layout(std430, binding = 4) buffer ConstraintsIn {
	ConstraintPair constraints[ ];
};

layout(std430, binding = 5) buffer NumJointsIn {
	uint nJoints[ ];
};

layout(std430, binding = 6) buffer CorrPosIn {
	vec3 corrPos[ ];
};

layout(std430, binding = 7) buffer CorrAngIn {
	vec3 corrAng[ ];
};

layout (push_constant) uniform PushConsts {
    uint constraintCount;
} pushConsts;

layout (local_size_x = 64) in;

void main() 
{
    uvec3 id = gl_GlobalInvocationID; 

	uint index = id.x;
	if (index >= pushConsts.constraintCount) 
		return;

	ConstraintPair cp = constraints[index];
	int id0 = cp.id0;
	int id1 = cp.id1;

	vec3 r0 = cp.r00.xyz;
	vec3 r1 = cp.r11.xyz;

	float massInv0 = massInv[id0] * nJoints[id0];
	float massInv1 = massInv[id1] * nJoints[id1];

	mat3 I0 = inertiaWorldInv[id0] * nJoints[id0];
	mat3 I1 = inertiaWorldInv[id1] * nJoints[id1];

	float d = length(corrPos[index]);
	vec3 n = d > EPSILON ? normalize(corrPos[index]) : vec3(0, 0, 0);

	vec3 r0n = cross(r0, n);
	vec3 r1n = cross(r1, n);

	float w0 = massInv0 + dot(r0n, I0*r0n);
	float w1 = massInv1 + dot(r1n, I1*r1n);

	lambdaDeltaPosition[index] = (d / (w0 + w1)) * n;

	d = length(corrAng[index]);
	n = d > EPSILON ? corrAng[index] / d : vec3(0, 0, 0);
	
	w0 = dot(n, I0*n);
	w1 = dot(n, I1*n);

	lambdaDeltaAngular[index] = (abs(w0 + w1) > EPSILON ? d / (w0+w1) : 0) * n;
}