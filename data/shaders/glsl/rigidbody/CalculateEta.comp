#version 450
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#include "SharedData.glsl"

layout(std430, binding = 0) buffer EtaOut {
	float eta[ ];
};

layout(std430, binding = 1) buffer VelocityIn {
	vec3 velocity[ ];
};

layout(std430, binding = 2) buffer AngularVelocityIn {
	vec3 angularVelocity[ ];
};

layout(std430, binding = 3) buffer ForceExtIn {
	vec3 forceExt[ ];
};

layout(std430, binding = 4) buffer TorqueExtIn {
	vec3 torqueExt[ ];
};

layout(std430, binding = 5) buffer GravityIn {
	vec3 gravity[ ];
};

layout(std430, binding = 6) buffer MassInvIn {
	float massInv[ ];
};

layout(std430, binding = 7) buffer InertiaIn {
	mat3 inertiaInv[ ];
};

layout(std430, binding = 8) buffer JacobianIn {
	vec3 J[ ];
};

layout(std430, binding = 9) buffer ResIn {
	float restitution[ ];
};

layout(std430, binding = 10) buffer ContactsIn {
	ContactPair contacts[ ];
};

layout (binding = 11) uniform UBO {
	RigidBodySolverState state;
} params;

layout (binding = 12) uniform CNT {
	uint contactNum;
};

layout (local_size_x = 64) in;

void main() 
{
    uvec3 id = gl_GlobalInvocationID; 

	uint index = id.x;
	if (index >= contactNum) 
		return;

    float dt = params.state.dt;
    vec3 g = params.state.gravity.xyz;
    float invDt = 1 / dt;

    float eta_i = 0;

    int id0 = contacts[index].id0;
    int id1 = contacts[index].id1;
    uint cType = contacts[index].cType;

    vec3 extLinearAccel = g + gravity[id0] + invDt * massInv[id0] * forceExt[id0];
    vec3 extAngularAccel = invDt * inertiaInv[id0] * torqueExt[id0];
    eta_i -= dot(J[4 * index], invDt * velocity[id0] + extLinearAccel);
    eta_i -= dot(J[4 * index + 1], invDt * angularVelocity[id0] + extAngularAccel);

    if (id1 != INVALID_ID) {
        extLinearAccel = g + gravity[id1] + invDt * massInv[id1] * forceExt[id1];
        extAngularAccel = invDt * inertiaInv[id1] * torqueExt[id1];
        eta_i -= dot(J[4 * index + 2], invDt * velocity[id1] + extLinearAccel);
        eta_i -= dot(J[4 * index + 3], invDt * angularVelocity[id1] + extAngularAccel);
    }
    
    
    if (cType <= CT_NONPENETRATION)
        eta_i += BETA * invDt * invDt * contacts[index].distance;

    float res_i =  restitution[id0];
    vec3 relVel_i = -velocity[id0];
    vec3 normal_i = contacts[index].normal0.xyz;

    if (id1 != INVALID_ID) {
        res_i = sqrt(res_i*restitution[id1]);
        relVel_i += velocity[id1];
    }

    float vel_mag = dot(normal_i, relVel_i);

    if(vel_mag < 0){
        eta_i -= res_i*invDt*vel_mag;
    }

    eta[index] = eta_i;
}