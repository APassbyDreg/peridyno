#version 450
#extension GL_GOOGLE_include_directive : enable
#include "SharedData.glsl"

layout(std430, binding = 0) buffer AccelOut {
	vec3 accel[ ];
};

layout(std430, binding = 1) buffer ContactIdIn {
	int id1[ ];
};

layout(std430, binding = 2) buffer ContactPairIdIn {
	int val1[ ];
};

layout(std430, binding = 3) buffer LambdaIn {
	float lambda[ ];
};

layout(std430, binding = 4) buffer BIn {
	vec3 B[ ];
};

layout (binding = 5) uniform UBO {
	ContactInfo cntInfo;
};

layout (local_size_x = 64) in;

void main() 
{
    uvec3 id = gl_GlobalInvocationID; 

	uint index = id.x;
	if (index >= cntInfo.constraintNum) 
		return;

    if (id1[index] == INVALID_ID)
        return;

    if (index == 0 || id1[index] != id1[index-1])
    {
        int start_index = int(index);
        int bodyId = id1[index];

        while(id1[start_index] == bodyId && start_index < cntInfo.constraintNum)
        {
            int pairId = val1[start_index];

            float lambda_i = lambda[pairId];

            float frac = pairId < cntInfo.contactNum ? SPLIT_MASS : 0.5 * SPLIT_MASS;
            // vec3 B1 = lambda_i*B[4*pairId];
            // vec3 B2 = lambda_i*B[4*pairId + 1];
            vec3 B3 = frac*lambda_i*B[4*pairId + 2];
            vec3 B4 = frac*lambda_i*B[4*pairId + 3];

            // accel[2*bodyId] += B1;
            // accel[2*bodyId + 1] += B2;

            // if (id1 != INVALID_ID) {
                accel[2*bodyId] += B3;
                accel[2*bodyId + 1] += B4;
            // }
            start_index++;
        }
    }
}