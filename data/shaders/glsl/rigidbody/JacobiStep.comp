#version 450
#extension GL_GOOGLE_include_directive : enable
#include "SharedData.glsl"

layout(std430, binding = 0) buffer LabmdaDeltaOut {
	float lambdaDelta[ ];
};

layout(std430, binding = 1) buffer LambdaOut {
	float lambda[ ];
};

layout(std430, binding = 2) buffer MassIn {
	float mass[ ];
};

layout(std430, binding = 3) buffer AccelIn {
	vec3 accel[ ];
};

layout(std430, binding = 4) buffer JOut {
	vec3 J[ ];
};

layout(std430, binding = 5) buffer EtaIn {
	float eta[ ];
};

layout(std430, binding = 6) buffer DIn {
	float d[ ];
};

layout(std430, binding = 7) buffer FrictionIn {
	float friction[ ];
};

layout(std430, binding = 8) buffer ContactListIn {
	ContactPair contacts[ ];
};

layout (binding = 9) uniform UBO {
	RigidBodySolverState state;
} params;

layout (binding = 10) uniform CNT {
	uint constraintNum;
};

layout (local_size_x = 64) in;

void main() 
{
    uvec3 id = gl_GlobalInvocationID; 

	uint index = id.x;
	if (index >= constraintNum) 
		return;

	int id0 = contacts[index].id0;
    int id1 = contacts[index].id1;
    uint cType = contacts[index].cType;

	// BodyDef body0 = body[id0];
	// BodyDef body1 = body[id1];
	// float frictionLimit = min(body0.mass0, body0.mass1)*sqrt(body0.friction*body1.friction);


	float eta_i = eta[index];

	eta_i -= dot(J[4*index], accel[2*id0]);
	eta_i -= dot(J[4*index + 1], accel[2*id0 + 1]);

	if (id1 != INVALID_ID) {
		eta_i -= dot(J[4*index + 2], accel[2*id1]);
		eta_i -= dot(J[4*index + 3], accel[2*id1 + 1]);
	}

	float lambda_0 = lambda[index];
	float lambda_1 = lambda_0 + eta_i / d[index];
	if(cType <= CT_NONPENETRATION)
		lambda_1 = max(0, lambda_1);
	else
	{
		float frictionLimit = 0;
		float g = length(params.state.gravity);
		if(id1 == INVALID_ID){
			frictionLimit = g * mass[id0]*friction[id0];
		}
		else{
			frictionLimit = g * min(mass[id0], mass[id1])*sqrt(friction[id0]*friction[id1]);
		}

		lambda_1 = 0.8*max(-frictionLimit, min(lambda_1, frictionLimit));
	}

	lambda[index] = lambda_1;
	lambdaDelta[index] = lambda_1 - lambda_0;
}