#version 450
#extension GL_GOOGLE_include_directive : enable
#include "SharedData.glsl"
#include "../math/Quat.glsl"

layout(std430, binding = 0) buffer CorrAngOut {
	vec3 corrAng[ ];
};

layout(std430, binding = 1) buffer QuatIn {
	vec4 quat[ ];
};

layout(std430, binding = 2) buffer ConstraintsIn {
	ConstraintPair constraints[ ];
};

layout (push_constant) uniform PushConsts {
    uint constraintCount;
} pushConsts;

layout (local_size_x = 64) in;

void main() 
{
    uvec3 id = gl_GlobalInvocationID; 

	uint index = id.x;
	if (index >= pushConsts.constraintCount) 
		return;

	ConstraintPair cp = constraints[index];
	int id0 = cp.id0;
	int id1 = cp.id1;

	vec4 quat0 = quat_mul(cp.frame0, quat[id0]);
	vec4 quat1 = quat_mul(cp.frame1, quat[id1]);
	vec4 dQuat = quat_mul(quat0, quat_inverse(quat1));

	if (cp.rotDOF == 0u) { // Fixed / Fixed Slider
		dQuat -= cp.angle;
		corrAng[index] = -2.0f * dQuat.xyz;
	} else if (cp.rotDOF == 1u) { // Hinge / Rotational Slider
		// restrict axis
		vec3 n0 = quat_rotate(quat0, cp.n00.xyz);
		vec3 n1 = quat_rotate(quat1, cp.n10.xyz);
		corrAng[index] = cross(n0, n1);
		// apply angular limits
		vec3 n01 = quat_rotate(quat0, cp.n01.xyz);
		vec3 n11 = quat_rotate(quat1, cp.n11.xyz);
		vec3 cross01 = cross(n01, n11);
		float phi = degrees(asin(dot(cross01, n0)));
		phi = dot(n01, n11) < 0 ? 360.0f - phi : phi;
		phi += 360.0f * (float(phi < -180.0f) - float(phi > 180.0f));
		float phi1 = clamp(phi, cp.lowerAng[0], cp.upperAng[0]);
		n01 = rotate_vertex_position(n01, n0, phi1);
		corrAng[index] += cross(n01, n11) * float(phi > cp.upperAng[0] || phi < cp.lowerAng[0]);
	} else if (cp.rotDOF == 2u) { // ConeTwist
		dQuat = dQuat.w >= 0 ? dQuat : -dQuat;
		// decomposite cone / twist
		float qx = dQuat.x, qy = dQuat.y, qz = dQuat.z, qw = dQuat.w;
		float s = sqrt(qx * qx + qw * qw);
		vec4 qCone = (s >= EPSILON) ?
			vec4(0.0f, (qw*qy - qx*qz) / s, (qw*qz + qx*qy) / s, s) :
			vec4(0.0f, qy, qz, sqrt(1.0f - qy*qy - qz*qz));
		vec4 qTwist = (s >= EPSILON) ?
			vec4(qx, 0.0f, 0.0f, qw) / s :
			vec4(0.0f, 0.0f, 0.0f, 1.0f);
		/* -- calculate cone clamp -- */
		float x = qy, y = qz;
		float x2 = x * x, y2 = y * y;
		float xlim = sin(cp.upperAng[1] * 0.5f), ylim = sin(cp.upperAng[2] * 0.5f);
		float xlim2 = xlim * xlim, ylim2 = ylim * ylim;
		int nIter = 50;
		float t = 0.0f, v = x2 / xlim2 + y2 / ylim2 - 1.0f, dv;
		while (nIter > 0 && v >= EPSILON) {
			v = xlim2 * x2 * pow(xlim2 + t, -2.0f) + ylim2 * y2 * pow(ylim2 + t, -2.0f) - 1.0f;
			dv = -2.0f * xlim2 * x2 * pow(xlim2 + t, -3.0f) -2.0f * ylim2 * y2 * pow(ylim2 + t, -3.0f);
			t -= v / dv; --nIter;
		}
		x *= t / (xlim2 + t);
		y *= t / (ylim2 + t);
		qCone = vec4(0.0f, x, y, sqrt(1.0f - x * x - y * y));
		/* -- calculate twist clamp -- */
		float angTwist = qTwist.x;
		float dTwist = angTwist - clamp(angTwist, -sin(cp.upperAng[0] * 0.5f), sin(cp.upperAng[0] * 0.5f));
		qTwist = vec4(dTwist, 0.0f, 0.0f, sqrt(1.0f - dTwist * dTwist));
		/* -- cone clamp plus (mult) twist clamp -- */
		corrAng[index] = -2.0f * quat_mul(qTwist, qCone).xyz;
	} else {
		if (length(cp.n00.xyz) < EPSILON) { // P2P
			corrAng[index] = vec3(0, 0, 0);
		} else { // Gen6DOF
			vec3 dAng = quat2eulZYX(dQuat); // in xyz
			dAng -= clamp(dAng, cp.lowerAng.xyz, cp.upperAng.xyz);
			dQuat = eul2quatZYX(dAng);
			corrAng[index] = -2.0f * dQuat.xyz;
		}
	}
}