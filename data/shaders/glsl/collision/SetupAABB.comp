#version 450
#extension GL_GOOGLE_include_directive : enable
#include "../rigidbody/SharedData.glsl"
#include "../math/Quat.glsl"

layout(std430, binding = 0) buffer ABoxOut {
	AlignedBox3D aBox[ ];
};

layout(std430, binding = 1) buffer BoxIN {
	Box boxes[ ];
};

layout(std430, binding = 2) buffer CapsuleIn {
	Capsule capsules[ ];
};

layout(std430, binding = 3) buffer SphereIn {
	Sphere spheres[ ];
};

layout (binding = 4) uniform UniformOffset {
	ElementOffset eleOffset;
} params;

layout (local_size_x = 64) in;

layout (push_constant) uniform PushConsts {
	uint elementCount;
} pushConsts;

void main() 
{
	uvec3 id = gl_GlobalInvocationID; 

	uint index = id.x;
	if (index >= pushConsts.elementCount) 
		return;

	ElementOffset eleOffset = params.eleOffset;
	if(index < eleOffset.box_bound)
	{
		vec3 halfLength = boxes[index].halfLength.xyz;
		vec4 quat = boxes[index].rot;

		vec3 hx = quat_rotate(quat, vec3(halfLength.x, 0, 0));
		vec3 hy = quat_rotate(quat, vec3(0, halfLength.y, 0));
		vec3 hz = quat_rotate(quat, vec3(0, 0, halfLength.z));

		aBox[index].v0 = boxes[index].center.xyz - abs(hx) - abs(hy) - abs(hz);
		aBox[index].v1 = boxes[index].center.xyz + abs(hx) + abs(hy) + abs(hz);
	}
	else if(index < eleOffset.capsule_bound)
	{
        uint cId = index - eleOffset.box_bound;
		Capsule capsule_i = capsules[cId];

		vec3 hx = quat_rotate(capsule_i.rot, vec3(capsule_i.halfLength, 0, 0));

		aBox[index].v0 = capsule_i.center.xyz - abs(hx) - vec3(capsule_i.radius);
		aBox[index].v1 = capsule_i.center.xyz + abs(hx) + vec3(capsule_i.radius);
	}
    else
	{
		uint sId = index - eleOffset.capsule_bound;
		Sphere sphere_i = spheres[sId];

		aBox[index].v0 = sphere_i.center - vec3(sphere_i.radius);
		aBox[index].v1 = sphere_i.center + vec3(sphere_i.radius);
	}
}