#version 450
#extension GL_GOOGLE_include_directive : enable
#include "../rigidbody/SharedData.glsl"
#include "../math/Quat.glsl"

layout(std430, binding = 0) buffer NumOut {
	int num[ ];
};

layout(std430, binding = 1) buffer BoxIn {
	Box boxes[ ];
};

layout(std430, binding = 2) buffer CapsuleIn {
	Capsule capsules[ ];
};

layout(std430, binding = 3) buffer SphereIn {
	Sphere spheres[ ];
};

layout (binding = 4) uniform UniformOffset {
	ElementOffset eleOffset;
} params;

layout (binding = 5) uniform ENT {
    uint elmentCount;
};

layout (local_size_x = 64) in;

void main() 
{
    uvec3 id = gl_GlobalInvocationID; 

	uint index = id.x;
	if (index >= elmentCount) 
		return;

	ElementOffset eleOffset = params.eleOffset;

	if(index < eleOffset.box_bound)
	{
		uint bId = index;
		Box box_i = boxes[bId];

		vec3 halfLength = boxes[bId].halfLength.xyz;
		vec3 hx = quat_rotate(boxes[bId].rot, vec3(halfLength.x, 0, 0));
		vec3 hy = quat_rotate(boxes[bId].rot, vec3(0, halfLength.y, 0));
		vec3 hz = quat_rotate(boxes[bId].rot, vec3(0, 0, halfLength.z));

		float level = boxes[bId].center.y - abs(hx.y) - abs(hy.y) - abs(hz.y);

		vec3 p0 = boxes[bId].center.xyz - hx - hy - hz;
		vec3 p1 = boxes[bId].center.xyz - hx - hy + hz;
		vec3 p2 = boxes[bId].center.xyz - hx + hy - hz;
		vec3 p3 = boxes[bId].center.xyz - hx + hy + hz;
		vec3 p4 = boxes[bId].center.xyz + hx - hy - hz;
		vec3 p5 = boxes[bId].center.xyz + hx - hy + hz;
		vec3 p6 = boxes[bId].center.xyz + hx + hy - hz;
		vec3 p7 = boxes[bId].center.xyz + hx + hy + hz;

		int cnt_num = 0;
		if(p0.y < GROUND_LELEL) cnt_num++;
		if(p1.y < GROUND_LELEL) cnt_num++;
		if(p2.y < GROUND_LELEL) cnt_num++;
		if(p3.y < GROUND_LELEL) cnt_num++;
		if(p4.y < GROUND_LELEL) cnt_num++;
		if(p5.y < GROUND_LELEL) cnt_num++;
		if(p6.y < GROUND_LELEL) cnt_num++;
		if(p7.y < GROUND_LELEL) cnt_num++;

		num[index] = cnt_num;
	}
    else if(index < eleOffset.capsule_bound)
	{
		uint cId = index - eleOffset.box_bound;
		Capsule capsule_i = capsules[cId];

		vec3 hx = quat_rotate(capsule_i.rot, vec3(capsule_i.halfLength, 0, 0));
		vec3 p0 = capsule_i.center.xyz - hx - vec3(0, capsule_i.radius, 0);
		vec3 p1 = capsule_i.center.xyz + hx - vec3(0, capsule_i.radius, 0);

		int cnt_num = 0;
		if(p0.y < GROUND_LELEL) cnt_num++;
		if(p1.y < GROUND_LELEL) cnt_num++;

		num[index] = cnt_num;
	} 
	else
	{
		uint sId = index - eleOffset.capsule_bound;
		Sphere sphere_i = spheres[sId];

		vec3 p0 = sphere_i.center - vec3(0, sphere_i.radius, 0);

		int cnt_num = 0;
		if(p0.y < GROUND_LELEL) cnt_num++;

		num[index] = cnt_num;
	}
}