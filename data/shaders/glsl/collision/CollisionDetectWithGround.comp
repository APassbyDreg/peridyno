#version 450
#extension GL_GOOGLE_include_directive : enable
#include "../rigidbody/SharedData.glsl"
#include "../math/Quat.glsl"

layout(std430, binding = 0) buffer ContactsOut {
	ContactPair contacts[ ];
};

layout(std430, binding = 1) buffer IndexIn {
	int offsets[ ];
};

layout(std430, binding = 2) buffer BoxIn {
	Box boxes[ ];
};

layout(std430, binding = 3) buffer CapsuleIn {
	Capsule capsules[ ];
};

layout(std430, binding = 4) buffer SphereIn {
	Sphere spheres[ ];
};

layout (binding = 5) uniform UniformOffset {
	ElementOffset eleOffset;
} params;

layout (binding = 6) uniform ENT {
    uint elmentCount;
};

layout (local_size_x = 64) in;

void CalculateContactPair(inout ContactPair cnt, uint bodyId, vec3 p, float ground)
{
    cnt.pos0 = vec4(p, 0);
    cnt.pos1 = vec4(0);
    cnt.normal0 = vec4(0, -1, 0, 0);
    cnt.normal1 = vec4(0, 0, 0, 0);
    cnt.distance =  ground - p.y;
    cnt.cType = uint(CT_BOUNDARY);
    cnt.id0 = int(bodyId);
    cnt.id1 = INVALID_ID;
}

void main() 
{
    uvec3 id = gl_GlobalInvocationID; 

	uint index = id.x;
	if (index >= elmentCount) 
		return;

    ElementOffset eleOffset = params.eleOffset;
    if(index < eleOffset.box_bound)
	{
		uint bId = index;

        vec3 halfLength = boxes[bId].halfLength.xyz;
        vec3 hx = quat_rotate(boxes[bId].rot, vec3(halfLength.x, 0, 0));
        vec3 hy = quat_rotate(boxes[bId].rot, vec3(0, halfLength.y, 0));
        vec3 hz = quat_rotate(boxes[bId].rot, vec3(0, 0, halfLength.z));

        vec3 p0 = boxes[bId].center.xyz - hx - hy - hz;
        vec3 p1 = boxes[bId].center.xyz - hx - hy + hz;
        vec3 p2 = boxes[bId].center.xyz - hx + hy - hz;
        vec3 p3 = boxes[bId].center.xyz - hx + hy + hz;
        vec3 p4 = boxes[bId].center.xyz + hx - hy - hz;
        vec3 p5 = boxes[bId].center.xyz + hx - hy + hz;
        vec3 p6 = boxes[bId].center.xyz + hx + hy - hz;
        vec3 p7 = boxes[bId].center.xyz + hx + hy + hz;

        int cnt_num = 0;
        ContactPair ctPair;
        if(p0.y < GROUND_LELEL) {
            CalculateContactPair(ctPair, index, p0, GROUND_LELEL);
            int offset = offsets[index];
            contacts[offset+cnt_num] = ctPair;
            cnt_num++;
        }

        if(p1.y < GROUND_LELEL) {
            CalculateContactPair(ctPair, index, p1, GROUND_LELEL);
            int offset = offsets[index];
            contacts[offset+cnt_num] = ctPair;
            cnt_num++;
        }

        if(p2.y < GROUND_LELEL) {
            CalculateContactPair(ctPair, index, p2, GROUND_LELEL);
            int offset = offsets[index];
            contacts[offset+cnt_num] = ctPair;
            cnt_num++;
        }

        if(p3.y < GROUND_LELEL) {
            CalculateContactPair(ctPair, index, p3, GROUND_LELEL);
            int offset = offsets[index];
            contacts[offset+cnt_num] = ctPair;
            cnt_num++;
        }

        if(p4.y < GROUND_LELEL) {
            CalculateContactPair(ctPair, index, p4, GROUND_LELEL);
            int offset = offsets[index];
            contacts[offset+cnt_num] = ctPair;
            cnt_num++;
        }

        if(p5.y < GROUND_LELEL) {
            CalculateContactPair(ctPair, index, p5, GROUND_LELEL);
            int offset = offsets[index];
            contacts[offset+cnt_num] = ctPair;
            cnt_num++;
        }

        if(p6.y < GROUND_LELEL) {
            CalculateContactPair(ctPair, index, p6, GROUND_LELEL);
            int offset = offsets[index];
            contacts[offset+cnt_num] = ctPair;
            cnt_num++;
        }

        if(p7.y < GROUND_LELEL) {
            CalculateContactPair(ctPair, index, p7, GROUND_LELEL);
            int offset = offsets[index];
            contacts[offset+cnt_num] = ctPair;
            cnt_num++;
        }
    }
    else if(index < eleOffset.capsule_bound)
	{
        uint cId = index - eleOffset.box_bound;
		Capsule capsule_i = capsules[cId];

		vec3 hx = quat_rotate(capsule_i.rot, vec3(capsule_i.halfLength, 0, 0));
		vec3 p0 = capsule_i.center.xyz - hx - vec3(0, capsule_i.radius, 0);
		vec3 p1 = capsule_i.center.xyz + hx - vec3(0, capsule_i.radius, 0);

        int cnt_num = 0;
        ContactPair ctPair;
		if(p0.y < GROUND_LELEL) {
            CalculateContactPair(ctPair, index, p0, GROUND_LELEL);
            int offset = offsets[index];
            contacts[offset+cnt_num] = ctPair;
            cnt_num++;
        }
		if(p1.y < GROUND_LELEL) {
            CalculateContactPair(ctPair, index, p1, GROUND_LELEL);
            int offset = offsets[index];
            contacts[offset+cnt_num] = ctPair;
            cnt_num++;
        }
    }
    else
    {
        uint sId = index - eleOffset.capsule_bound;
		Sphere sphere_i = spheres[sId];

		vec3 p0 = sphere_i.center - vec3(0, sphere_i.radius, 0);
        ContactPair ctPair;
        if(p0.y < GROUND_LELEL) {
            CalculateContactPair(ctPair, index, p0, GROUND_LELEL);
            int offset = offsets[index];
            contacts[offset] = ctPair;
        }
    }
}