#version 450
#extension GL_GOOGLE_include_directive : enable
#include "../rigidbody/SharedData.glsl"
#include "../math/Quat.glsl"

layout(std430, binding = 0) buffer DPosOut {
	vec3 dpos[ ];
};

layout(std430, binding = 1) buffer DQuatOut {
	vec4 dQuat[ ];
};

layout(std430, binding = 2) buffer ConstraintPairIdIn {
	int id1[ ];
};

layout(std430, binding = 3) buffer ConstraintPairValIn {
	int val1[ ];
};

layout(std430, binding = 4) buffer CenterIn {
	vec3 center[ ];
};

layout(std430, binding = 5) buffer QuatIn {
	vec4 quat[ ];
};


layout(std430, binding = 6) buffer MassInvIn {
	float massInv[ ];
};

layout(std430, binding = 7) buffer inertiaWorldInvIn {
	mat3 inertiaWorldInv[ ];
};

layout(std430, binding = 8) buffer LambdaPositionIn {
	vec3 lambdaDeltaPosition[ ];
};

layout(std430, binding = 9) buffer ConstraintsIn {
	ConstraintPair constraints[ ];
};

layout (binding = 10) uniform CNT {
    uint constraintCount;
};

layout (local_size_x = 64) in;

void main() 
{
    uvec3 id = gl_GlobalInvocationID; 

	uint index = id.x;
	if (index >= constraintCount || id1[index] < 0) 
		return;

    if (index == 0 || id1[index] != id1[index-1])
    {
        int start_index = int(index);
        int bodyId = id1[index];

        vec3 center_i = center[bodyId];
        float massInv_i = massInv[bodyId];
        vec4 quat_i = quat[bodyId];
        mat3 inertiaWorldInv_i = inertiaWorldInv[bodyId];

        vec3 dp_i = vec3(0);
        vec4 dq_i = vec4(0);
        while(id1[start_index] == bodyId && start_index < constraintCount)
        {
            int cId = val1[start_index];
            
            vec3 p_i = lambdaDeltaPosition[cId];
            dp_i -= p_i*massInv_i;
            dq_i -= 0.5*quat_mul(vec4(inertiaWorldInv_i*cross(constraints[cId].r1.xyz, p_i), 0), quat_i);

            start_index++;
        }

        dpos[bodyId] += dp_i;
        dQuat[bodyId] += dq_i;
    }
}