#version 450
#extension GL_GOOGLE_include_directive : enable
#include "../rigidbody/SharedData.glsl"
#include "CollisionDetection.glsl"
#include "../math/Quat.glsl"

layout(std430, binding = 0) buffer ContactsIn {
	ContactPair contactPair[ ];
};

layout(std430, binding = 1) buffer StartIn {
	int startIndex[ ];
};

layout(std430, binding = 2) buffer PairIn {
	uvec2 pairIds[ ];
};

layout(std430, binding = 3) buffer BoxIn {
	Box boxes[ ];
};

layout(std430, binding = 4) buffer CapsuleIn {
	Capsule capsules[ ];
};

layout(std430, binding = 5) buffer SphereIn {
	Sphere spheres[ ];
};

layout(std430, binding = 6) buffer ShapeTypeIn {
	ShapeType sType[ ];
};

layout (binding = 7) uniform UniformOffset {
	ElementOffset eleOffset;
} params;

layout (push_constant) uniform PushConsts {
    uint contactNum;
} pushConsts;

layout (local_size_x = 64) in;

void SetData(int start, Manifold m, uvec2 pair, bool exchange)
{
	if (m.contactCount > 0) {
		for(int i = 0; i < m.contactCount; i++) {
			ContactPair cPair;
			cPair.pos0 = vec4(m.position[i], 0);
			cPair.pos1 = vec4(m.position[i], 0);
			cPair.normal0 = vec4(m.normal, 0);
			cPair.normal1 = -vec4(m.normal, 0);
			cPair.id0 = exchange ? int(pair.y) : int(pair.x);
			cPair.id1 = exchange ? int(pair.x) : int(pair.y);
			cPair.cType = CT_NONPENETRATION;
			cPair.distance = -m.penetration[i];

			contactPair[start+i] = cPair;
		}
	}
}

void main() 
{
    uvec3 id = gl_GlobalInvocationID; 

	uint index = id.x;
	if (index >= pushConsts.contactNum) 
		return;

	int start_i = startIndex[index];
	uvec2 pair_i = pairIds[index];
	ElementOffset eleOffset = params.eleOffset;

	ShapeType sA = sType[pair_i.x];
	ShapeType sB = sType[pair_i.y];

	Manifold m;
	m.contactCount = 0;

	bool exchange_id = false;
	if((ST_Box & sA) > 0 && (ST_Box & sB) > 0)
	{
		float maxDist = FLOAT_MAX;
		int maxId = -1;
		OBBtoOBB(m, boxes[pair_i.x], boxes[pair_i.y]);
		SetData(start_i, m, pair_i, exchange_id);
	}
	else if((ST_Sphere & sA) > 0 && (ST_Sphere & sB) > 0)
	{
		SpheretoSphere(m, spheres[pair_i.x - eleOffset.capsule_bound], spheres[pair_i.y - eleOffset.capsule_bound]);
		SetData(start_i, m, pair_i, exchange_id);
	}
	else if((ST_Segement & sA) > 0 && (ST_Segement & sB) > 0)
	{
		CapsuletoCapsule(m, capsules[pair_i.x - eleOffset.box_bound], capsules[pair_i.y - eleOffset.box_bound]);
		SetData(start_i, m, pair_i, exchange_id);
	}
	else if(((ST_Sphere & sA) > 0 && (ST_Segement & sB) > 0) || ((ST_Segement & sA) > 0 && (ST_Sphere & sB) > 0))
	{
		uint iA = (ST_Sphere & sA) > 0 ? pair_i.x : pair_i.y;
		uint iB = (ST_Sphere & sA) > 0 ? pair_i.y : pair_i.x;
		exchange_id = (ST_Sphere & sA) > 0 ? false : true;
		SpheretoCapsule(m, spheres[iA - eleOffset.capsule_bound], capsules[iB - eleOffset.box_bound]);
		SetData(start_i, m, pair_i, exchange_id);
	}
	else if(((ST_Sphere & sA) > 0 && (ST_Box & sB) > 0) || ((ST_Box & sA) > 0 && (ST_Sphere & sB) > 0))
	{
		uint iA = (ST_Sphere & sA) > 0 ? pair_i.x : pair_i.y;
		uint iB = (ST_Sphere & sA) > 0 ? pair_i.y : pair_i.x;
		exchange_id = (ST_Sphere & sA) > 0 ? false : true;
		SpheretoBox(m, spheres[iA - eleOffset.capsule_bound], boxes[iB]);
		SetData(start_i, m, pair_i, exchange_id);
	}
	else if(((ST_Segement & sA) > 0 && (ST_Box & sB) > 0) || ((ST_Box & sA) > 0 && (ST_Segement & sB) > 0))
	{
		uint iA = (ST_Segement & sA) > 0 ? pair_i.x : pair_i.y;
		uint iB = (ST_Segement & sA) > 0 ? pair_i.y : pair_i.x;
		exchange_id = (ST_Segement & sA) > 0 ? false : true;
		CapsuletoBox(m, capsules[iA - eleOffset.box_bound], boxes[iB]);
		SetData(start_i, m, pair_i, exchange_id);
	}

}