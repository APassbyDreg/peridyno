#version 450
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable

#include "../rigidbody/SharedData.glsl"
#include "../math/Primitive3D.glsl"
#include "../math/Quat.glsl"

layout(std430, binding = 0) buffer CenterIn {
	IPoint iPts[ ];
};

layout(std430, binding = 1) buffer StartIn {
	int startIndex[ ];
};

layout(std430, binding = 2) buffer BoxOut {
	Box boxes[ ];
};

layout(std430, binding = 3) buffer CapsuleOut {
	Capsule capsules[ ];
};

layout(std430, binding = 4) buffer SphereOut {
	Sphere spheres[ ];
};

layout (binding = 5) uniform UniformOffset {
	ElementOffset eleOffset;
};

layout (binding = 6) uniform UniformRay {
	Ray3D ray;
};

layout (local_size_x = 64) in;

layout (push_constant) uniform PushConsts {
	uint totalNum;
} pushConsts;

void main() 
{
	uvec3 id = gl_GlobalInvocationID; 

	uint index = id.x;
	if (index >= pushConsts.totalNum) 
		return;

	ElementOffset offset = eleOffset;
	
	vec4 quat;
	vec3 center;
	AABB3D abox;

	Ray3D rayPrime;
	if(index < eleOffset.box_bound)
	{
		uint bId = index;
		Box box_i = boxes[bId];
		vec3 halfLength = box_i.halfLength.xyz;

		quat =  box_i.rot;
		center = box_i.center.xyz;

		abox.v0 = -halfLength;
		abox.v1 = halfLength;

		vec4 quat_inverse = quat;
		quat_inverse.w = -quat.w;
		rayPrime.origin = quat_rotate(quat_inverse, ray.origin - center);
		rayPrime.direction = quat_rotate(quat_inverse, ray.direction);

		Segment3D interSeg;
		int offset_i = startIndex[index];
		if(intersect(interSeg, rayPrime, abox) > 0)
		{
			IPoint ipt;
			ipt.id = index;
			ipt.point = vec4(quat_rotate(quat, interSeg.v0) + center, 0);
			iPts[offset_i] = ipt;
		}
	}
	else if(index < eleOffset.capsule_bound)
	{
        uint cId = index - eleOffset.box_bound;
		Capsule capsule_i = capsules[cId];

		quat =  capsule_i.rot;
		center = capsule_i.center.xyz;

		abox.v0 = -vec3(capsule_i.halfLength, capsule_i.radius, capsule_i.radius);
		abox.v1 = vec3(capsule_i.halfLength, capsule_i.radius, capsule_i.radius);

		vec4 quat_inverse = quat;
		quat_inverse.w = -quat.w;
		rayPrime.origin = quat_rotate(quat_inverse, ray.origin - center);
		rayPrime.direction = quat_rotate(quat_inverse, ray.direction);

		Segment3D interSeg;
		int offset_i = startIndex[index];
		if(intersect(interSeg, rayPrime, abox) > 0)
		{
			IPoint ipt;
			ipt.id = index;
			ipt.point = vec4(quat_rotate(quat, interSeg.v0) + center, 0);
			iPts[offset_i] = ipt;
		}
	}
    else
	{
		uint sId = index - eleOffset.capsule_bound;
		Sphere sphere_i = spheres[sId];

		Sphere3D sphere3d;
		sphere3d.center = sphere_i.center;
		sphere3d.radius = sphere_i.radius;

		//rotate ray
		rayPrime = ray;

		Segment3D interSeg;
		int offset_i = startIndex[index];
		if(intersect(interSeg, rayPrime, sphere3d) > 0)
		{
			IPoint ipt;
			ipt.id = index;
			ipt.point = vec4(interSeg.v0, 0);
			iPts[offset_i] = ipt;

			debugPrintfEXT("Intersection: %f %f %f \n", ipt.point.x, ipt.point.y, ipt.point.z);
		}
	}
}