#version 450
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#include "SharedDataInFluid.glsl"

layout(std430, binding = 0) buffer VelUOut {
	float vel_u[ ];
};

layout(std430, binding = 1) buffer VelVOut {
	float vel_v[ ];
};

layout(std430, binding = 2) buffer VelWOut {
	float vel_w[ ];
};

layout(std430, binding = 3) buffer NewVelIn {
	vec3 vel_new[ ];
};

layout(std430, binding = 4) buffer VelIn {
	vec3 vel[ ];
};

layout (binding = 5) uniform UBO {
	Array3DInfo arrayInfo;
} params;

layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

void main() 
{
    uvec3 id = gl_GlobalInvocationID; 

    Array3DInfo aInfo = params.arrayInfo;
    uint i = id.x;
    uint j = id.y;
    uint k = id.z;

    if (!inside(i, j, k, aInfo)) 
		return;

    uint nx = aInfo.nx;
    uint ny = aInfo.ny;
    uint nz = aInfo.nz;

    Array3DInfo aUInfo = params.arrayInfo;  aUInfo.nx = nx+1;   aUInfo.nxy = aUInfo.nx * aUInfo.ny;
    Array3DInfo aVInfo = params.arrayInfo;  aVInfo.ny = ny+1;   aVInfo.nxy = aVInfo.nx * aVInfo.ny;
    Array3DInfo aWInfo = params.arrayInfo;  aWInfo.nz = nz+1;   aWInfo.nxy = aWInfo.nx * aWInfo.ny;

    uint k0 = INDEX(i, j, k, aInfo);
    uint ki = INDEX(i+1, j, k, aInfo);
    uint kj = INDEX(i, j+1, k, aInfo);
    uint kk = INDEX(i, j, k+1, aInfo);

    if(i < nx - 1)
        vel_u[INDEX(i + 1, j, k, aUInfo)] = 0.5*(vel[k0].x+vel[ki].x);
        //vel_u[INDEX(i + 1, j, k, aUInfo)] += INTER_WEIGHT*(0.5*(vel_new[k0].x+vel_new[ki].x) - 0.5*(vel[k0].x+vel[ki].x));

    if(j < ny - 1)
        vel_v[INDEX(i, j + 1, k, aVInfo)] = 0.5*(vel[k0].y+vel[kj].y); 
        //vel_v[INDEX(i, j + 1, k, aVInfo)] += INTER_WEIGHT*(0.5*(vel_new[k0].y+vel_new[kj].y) - 0.5*(vel[k0].y+vel[kj].y));
    
    if(k < nz - 1)
        vel_w[INDEX(i, j, k + 1, aWInfo)] = 0.5*(vel[k0].z+vel[kk].z);
        //vel_w[INDEX(i, j, k + 1, aWInfo)] += INTER_WEIGHT*(0.5*(vel_new[k0].z+vel_new[kk].z) - 0.5*(vel[k0].z+vel[kk].z));
}