#version 450
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_atomic_float : enable
#include "SharedDataInFluid.glsl"

layout(std430, binding = 0) buffer DensityOut {
	float dst[ ];
};

layout(std430, binding = 1) buffer DensityIn {
	float src[ ];
};

layout(std430, binding = 2) buffer VelWIn {
	float boundarySDF[ ];
};

layout (binding = 3) uniform UBO {
	Array3DInfo arrayInfo;
} params;

layout (push_constant) uniform PushConsts {
    float dt;
};

layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

Array3DInfo aInfo = params.arrayInfo;

uint nx = aInfo.nx;
uint ny = aInfo.ny;
uint nz = aInfo.nz;
uint nxy = aInfo.nxy;

vec3 calcVel(uint i, uint j, uint k)
{
    uint i_plus = clamp(i + 1, 0, nx - 1);
    uint i_minus = clamp(i - 1, 0, nx - 1);
    uint j_plus = clamp(j + 1, 0, ny - 1);
    uint j_minus = clamp(j - 1, 0, ny - 1);
    uint k_plus = clamp(k + 1, 0, nz - 1);
    uint k_minus = clamp(k - 1, 0, nz - 1);

    uint k0 = INDEX(i, j, k, aInfo);
    uint kip = INDEX(i_plus, j, k, aInfo);
    uint kim = INDEX(i_minus, j, k, aInfo);
    uint kjp = INDEX(i, j_plus, k, aInfo);
    uint kjm = INDEX(i, j_minus, k, aInfo);
    uint kkp = INDEX(i, j, k_plus, aInfo);
    uint kkm = INDEX(i, j, k_minus, aInfo);
    vec3 velm = -vec3(
        boundarySDF[k0] - boundarySDF[kim],
        boundarySDF[k0] - boundarySDF[kjm],
        boundarySDF[k0] - boundarySDF[kkm]
    ) / DEF_H;
    vec3 velp = vec3(
        boundarySDF[k0] - boundarySDF[kip],
        boundarySDF[k0] - boundarySDF[kjp],
        boundarySDF[k0] - boundarySDF[kkp]
    ) / DEF_H;
    return vec3(
        i == 0 ? velp.x : i == nx - 1 ? velm.x : 0.5f * (velp.x + velm.x),
        j == 0 ? velp.y : j == ny - 1 ? velm.y : 0.5f * (velp.y + velm.y),
        k == 0 ? velp.z : k == nz - 1 ? velm.z : 0.5f * (velp.z + velm.z)
    );
}

void main() 
{
    uvec3 id = gl_GlobalInvocationID;

    uint i = id.x;
    uint j = id.y;
    uint k = id.z;
	if (!inside(i, j, k, aInfo)) 
		return;

    uint i_plus = clamp(i+1, 0, nx - 1);
    
    uint index = INDEX(i, j, k, aInfo);
    vec3 vel_ijk = calcVel(i, j, k);

    float dRho = max(src[index] + CalculateBoundaryFraction(boundarySDF[index], DEF_H) - 1.0, 0);

    uint ix, iy, iz;
    float fx, fy, fz;
    float w000, w100, w010, w001, w111, w011, w101, w110;

    fx = i + vel_ijk.x;
    fy = j + vel_ijk.y;
    fz = k + vel_ijk.z;

    if (fx < 0.0) fx = 0.0;
    if (fx > nx - 1) fx = nx - 1.0;
    if (fy < 0.0) fy = 0.0f;
    if (fy > ny - 1) fy = ny - 1.0;
    if (fz < 0.0) fz = 0.0f;
    if (fz > nz - 1) fz = nz - 1.0;

    ix = uint(fx);      iy = uint(fy);		iz = uint(fz);
    fx -= ix;			fy -= iy;			fz -= iz;

    if (ix == nx - 1) { ix = nx - 2; fx = 1.0; }
    if (iy == ny - 1) { iy = ny - 2; fy = 1.0; }
    if (iz == nz - 1) { iz = nz - 2; fz = 1.0; }

    w000 = (1.0f - fx)*(1.0f - fy)*(1.0f - fz);
    w100 = fx*(1.0f - fy)*(1.0f - fz);
    w010 = (1.0f - fx)*fy*(1.0f - fz);
    w001 = (1.0f - fx)*(1.0f - fy)*fz;
    w111 = fx*fy*fz;
    w011 = (1.0f - fx)*fy*fz;
    w101 = fx*(1.0f - fy)*fz;
    w110 = fx*fy*(1.0f - fz);

    uint k0 = INDEX(ix, iy, iz, aInfo);

    vec3 vel = w000*calcVel(i, j, k) + w100*calcVel(i+1, j, k) +
        w010*calcVel(i, j+1, k) + w110*calcVel(i+1, j+1, k) +
        w001*calcVel(i, j, k+1) + w101*calcVel(i+1, j, k+1) +
        w011*calcVel(i, j+1, k+1) + w111*calcVel(i+1, j+1, k+1);

    vel_ijk = (vel + vel_ijk) * 0.5f;
    fx = i + vel_ijk.x;
    fy = j + vel_ijk.y;
    fz = k + vel_ijk.z;

    if (fx < 0.0) fx = 0.0;
    if (fx > nx - 1) fx = nx - 1.0;
    if (fy < 0.0) fy = 0.0f;
    if (fy > ny - 1) fy = ny - 1.0;
    if (fz < 0.0) fz = 0.0f;
    if (fz > nz - 1) fz = nz - 1.0;

    ix = uint(fx);      iy = uint(fy);		iz = uint(fz);
    fx -= ix;			fy -= iy;			fz -= iz;

    if (ix == nx - 1) { ix = nx - 2; fx = 1.0; }
    if (iy == ny - 1) { iy = ny - 2; fy = 1.0; }
    if (iz == nz - 1) { iz = nz - 2; fz = 1.0; }

    w000 = (1.0f - fx)*(1.0f - fy)*(1.0f - fz);
    w100 = fx*(1.0f - fy)*(1.0f - fz);
    w010 = (1.0f - fx)*fy*(1.0f - fz);
    w001 = (1.0f - fx)*(1.0f - fy)*fz;
    w111 = fx*fy*fz;
    w011 = (1.0f - fx)*fy*fz;
    w101 = fx*(1.0f - fy)*fz;
    w110 = fx*fy*(1.0f - fz);

    k0 = INDEX(ix, iy, iz, aInfo);

    atomicAdd(dst[index], -dRho);

    atomicAdd(dst[k0], w000 * dRho);
    atomicAdd(dst[k0 + 1], w100 * dRho);
    atomicAdd(dst[k0 + nx], w010 * dRho);
    atomicAdd(dst[k0 + nx + 1], w110 * dRho);
    atomicAdd(dst[k0 + nxy], w001 * dRho);
    atomicAdd(dst[k0 + nxy + 1], w101 * dRho);
    atomicAdd(dst[k0 + nxy + nx], w011 * dRho);
    atomicAdd(dst[k0 + nxy + nx + 1], w111 * dRho);
}