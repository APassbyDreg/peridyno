#version 450
#extension GL_GOOGLE_include_directive : enable
#include "../math/Quat.glsl"
#include "SharedDataHeightField.glsl"

#extension GL_EXT_debug_printf : enable

layout(std430, binding = 0) buffer Mh0 {
	vec2 mh0[ ];
};

layout(std430, binding = 1) buffer Mht {
	vec2 mht[ ];
};

layout (binding = 2) uniform UBOMh {
	Array2DInfo arrayInfo;
} MHparams;

layout (binding = 3) uniform UBOht {
	Array2DInfo arrayInfo;
} MTparams;

layout (binding = 4) uniform T{
	float mt;
} pushConsts;



vec2 complex_exp(float v){
	return vec2(cos(v), sin(v));
}

vec2 complex_add(vec2 a, vec2 b)
{
	return vec2(a.x + b.x, a.y + b.y);
}
vec2 complex_mult(vec2 ab, vec2 cd)
{
	return vec2(ab.x * cd.x - ab.y * cd.y, ab.x * cd.y + ab.y * cd.x);
}

vec2 conjugate(vec2 arg)
{
	return vec2(arg.x, -arg.y);
}


layout (local_size_x = 16, local_size_y = 16) in;
void main() 
{

	uvec3 id = gl_GlobalInvocationID; 
	uint x = id.x;
	uint y = id.y;


	Array2DInfo MHInfo = MHparams.arrayInfo;
	uint in_index = INDEX(x, y, MHInfo);
	
	Array2DInfo MTInfo = MTparams.arrayInfo;
	uint out_index = INDEX(x, y, MTInfo);
	uint in_mindex = (MTInfo.ny - y)*MHInfo.nx + (MTInfo.nx - x); // mirrored
	
	int out_width = int(MTInfo.nx);
	int patchSize = int(MTInfo.nx);
	
	float t = pushConsts.mt;

	
	// calculate wave vector
	vec2 k;
	k.x = (- out_width / 2.0 + x) * (2.0 * CUDART_PI_F / patchSize);
	k.y = (- out_width / 2.0 + y) * (2.0 * CUDART_PI_F / patchSize);
	
	
		// calculate dispersion w(k)
	float k_len = sqrt(k.x*k.x + k.y*k.y);
	float w = sqrt(9.81 * k_len);
	

	if (!inside(x, y, MTInfo)) 
		return;
	
	vec2 h0_k, h0_mk, result;

	h0_k = mh0[in_index];
	h0_mk = mh0[in_mindex];
	
	result = complex_add(complex_mult(h0_k, complex_exp(w * t)), complex_mult(conjugate(h0_mk), complex_exp(-w * t)));
	
	mht[out_index] = result;
}